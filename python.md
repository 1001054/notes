### 对象

对象由：标识、类型、value组成

本质：一个内存块，拥有特定的值，支持特定类型的相关操作。

1. 标识用于唯一标识对象，通常对应于对象在计算机内存中的地址。使用内置函数id(obj)可返回对象obj的标识。
2. 类型用于表示对象存储的 “数据” 的类型。类型可以限制对象的取值范围以及可执行的操作。可以使用type(obj)获得对象的所属类型。
3. 值表示对象所属的数据的信息。使用print(obj)可以直接打印出值。

### 引用

在Python中，变量是对象的引用。因为，变量存储的是对象的地址。变量通过地址引用了 “对象”。

变量位于栈内存，对象位于堆内存。

1. Python是动态类型语言：不需要显式的声明类型。根据变量引用的对象，解释器自动确定数据类型。
2. Python是强类型语言：每个对象都有数据类型，只支持该类型支持的操作。

### 标识符

用于变量、函数、类、模块的名称。

1. 区分大小写
2. 由字母、数字、下划线组成。不能由数字开头。
3. 不能使用关键字。
4. 以双下划线开头和结尾的名称通常有特殊含义，尽量避免这种写法。

规范：模块、包名和函数名为蛇形命名，类名为驼峰且首字母大写，常量名都为大写。

### 删除变量和垃圾回收机制

可以通过 del 语句删除不再使用的变量

```python
a = 123
del a
```

如果对象没有变量引用，就会被垃圾回收器回收，清空内存空间。

### 链式赋值

```python
x = y = 123
```

### 系列解包赋值

```python
a,b,c = 4,5,6
#变量交换
a,b = b,a
```

### 常量

Python不支持常量，即没有语法规则限制一个常量的值，我们只能约定常量的命名规则，以及在程序的逻辑上不对常量的值做出修改。

### 运算符

1. / ：浮点数除法
2. //：整数除法
3. **：幂

### 三种进制

1. 二进制：0b或0B
2. 八进制：0o或0O
3. 十六进制：0x或0X

### 类型转换

1. 整数转换：int(3.14)、float(1)
2. 自动转型：整数和浮点数混合运算时，表达式结果自动转型成浮点数。
3. 整数四舍五入：round(value)

（所有的转换和运算都不会改变原有的值，而是产生新的值）

### 逻辑运算符

1. （短路）逻辑或：or
2. （短路）逻辑与：and
3. 逻辑非：not

### 同一运算符

1. is：判断两个标识符是不是同一个对象
2. is not：判断两个标识符是不是引用不同的对象

### 整数缓存

Python仅仅对比较小的整数对象进行缓存。

```python
a = 100
b = 100
#此时a和b的地址相同
a is b 
```



1. 命令行：（范围是 [-5, 256]）
2. 文件或Pycharm：（范围是 [-5, 任意正整数]) 这是因为解释器做了一部分优化。

### 字符串编码

Python3直接支持Unicode，可以表示世界上任何书面语言的字符。Python3的字符默认就是16位Unicode编码，ASCII码是Unicode编码的子集。

1. 使用内置函数ord()可以把字符转换成对应的Unicode码
2. 使用内置函数chr()可以把十进制数字转换成对应的字符

### 引号创建字符串

1. 可以通过单引号或双引号创建字符串。

   ``` python
   a = "I'm a boy."
   b = 'He is a "BOY".'
   ```

   

2. 连续三个单引号或三个双引号，可以创建多行字符串。

   ```python
   resume = '''name="Tom"
   age=3
   address="Sun street"
   '''
   ```

### 转义字符

| 转义字符     | 描述             |
| ------------ | ---------------- |
| \\(在行尾时) | 续行符           |
| \\\\         | 反斜杠符号       |
| \\'          | 单引号           |
| \\"          | 双引号           |
| \\b          | 退格 (Backspace) |
| \\n          | 换行             |
| \\t          | 横向制表符       |
| \\r          | 回车             |

### 字符串拼接

``` python
#用加号
'a' + 'b'
#直接放在一起
'a' 'b'
#字符串复制
'a'*3
```

### 不换行打印

print方法会自动打印一个换行符，如果不想换行，可以加end参数。

```python
print("aa", end="")
print("bb", end="")
print("cc")
```

### 从控制台读取字符串

```python
name = input("请输入姓名：")
```

### 转型字符串

```python
#将数字转换位字符串
str(3.14)
```

### 从字符串中提取字符

字符串的本质是字符序列，可以通过在字符串后面添加 [ i ] , ( i 为索引位置)，提取字符。索引也可以为负数，此时索引为从右往左数。

### 字符串切片slice

格式为：string [起始偏移量 : 终止偏移量 : 步长]

1. 步长省略为1，string [0:] 终止偏移量省略到最后，string [:-1] 起始偏移量省略从头开始。都省略，只剩一个冒号为提取整个字符串。

2. string [::-1]，步长为负，从右到左反向提取。
3. 若起始偏移量和终止偏移量不在 [0, length-1] 这个范围，也不会报错。小于0当作0，超出范围则取最后一个索引。

### 字符串分割和合并

1. split() 可以基于指定分割符将字符串分割成多个子字符串（存储到列表中）。如果不指定分割符，则默认使用空白字符（换行符/空格/制表符）

   ```python
   a = "abc drf cc"
   a.split()
   ```

2. join() 的作用和split() 作用刚好相反，用于将一系列子字符串连接起来。

   ```python
   a = ['ad', 'sdf', 'sdf']
   ''.join(a)
   ```

3. 使用 + ，会生成新的字符串对象，因此不推荐使用。而 join 函数在拼接前会计算所有字符串的长度，仅新建一次对象。

### 字符串驻留机制和字符串比较

字符串驻留：相同的字符串，只会被存放在字符串驻留池中一次。（只支持那些仅包含下划线、字母和数字的字符串）

``` python
a = "abd"
b = "abd"
#true
a is b

c = "ab&"
d = "ab&"
#false
c is d
```

### 常用查找方法

```python
#字符串长度
len(a)

#是否以参数开头
a.startswith("abc")

#是否以参数结尾
a.endswith("abv")

#第一次出现指定字符串的位置
a.find('a')

#最后一次出现指定字符串的位置
a.rfind('a')

#参数出现的次数
a.count("a")

#所有字符全是字母或数字
a.isalnum()

#去除字符串首尾指定信息，无参去空格
a.strip()

#首字母大写
a.capitalize()

#每个单词首字母大写
a.title()

#所有字符全大写
a.upper()

#所有字符全小写
a.lower()

#所有字符大小写转换
a.swapcase()

#字符串排版
a="abc"
a.center(10,"*")      #'***abc****'
a.center(10)          #'   abc    '
a.ljust(10,"*")       #'abc*******'

#是否都是字母或汉字
isalpha()

#是否都是数字
isdigit()
```

### 字符串格式化

```python
a = "名字是：{0}，年龄是：{1}，请{0}好好吃饭"
a.format("Jack", 18)

b = "名字是：{name}，年龄是：{age}"
b.format(name='Jack', age=18)
```

### 填充于对齐

^  <  > 分别是居中、左对齐、右对齐

冒号后面带填充的字符，只能是一个字符，不指定的话默认是用空格填充。

```python
"{:*>8}".format("235")
"I'm {0}, my phone number is {1:*^8}".format("Jack", "666")
```

### 数字格式化

1. {:.2f}：保留小数点后两位
2. {:+.2f}：带符号保留小数点后两位
3. {:.0f}：不带小数
4. {:0>2d}：数字补零（填充左边，宽度为2）
5. {:,}：以逗号分割的数字格式
6. {:.2%}：百分比格式
7. {:.2e}：指数记法

### 可变字符串

在Python中，字符串属于不可变对象，不支持原地修改，如果需要修改其中的值，只能创建新的字符串对象，或使用io.StringIO对象或array模块。

```python
import io
s = "Helloworld!"
sio = io.StringIO(s)
sio.getvalue()
#使指针指向第九个字符
sio.seek(9)
#替换字符
sio.write(".")
```

### 位运算符

```python
a = 0b11001
b = 0b01000
#按位或
c = a|b
#按位异或
c = a^b
#按位与
c = a&b
#位移
a<<2
```

### 序列

一种数据存储方式，用来存储一系列的数据。在内存中，序列就是一块用来存放多个值的连续内存空间。因为这些数据都是对象，所以序列中存储的实际上是这些对象的地址。

### 列表

1. 字符串和列表都是序列类型

2. 列表用于存储任意数量、任意类型的数据集合。

3. 列表是内置可变序列，是包含多个冤死的有序连续的内存空间。

4. 这些元素可以各不相同，可以是任意类型。

   ``` python
   #基本语法创建
   a = ["Jack", 13]
   #list()创建
   #使用list()可以将任何可迭代的数据转化成列表
   a = list()
   b = list(range(10))
   c = list("Hello")
   #推导式创建列表
   d = [x*2 for x in range(5) if x%2==0]
   ```

   

### range()创建整数列表

格式为：range(start, end, step)

1. start默认为0，step默认为1，负数为逆序。

2. 该方法返回的是一个range对象，而不是列表，通常使用list()方法将其转换成列表对象。

### 列表元素的增加与删除

当列表增加和删除元素时，列表会自动进行内存管理，减少了程序员的负担，但列表元素会大量移动，效率较低。如果只在列表尾部添加元素或删除元素，会大大提高列表的操作效率。

```python
a = [20, 30]
#在列表尾部添加新的元素
a.append(40)
#并不是真正的添加元素，而是创建了新的列表对象
a = a + [50, 60]
#将目标列表所有元素添加到本列表尾部，原地操作，不创建新的列表对象
a.extend([70, 80])
#将指定元素插入到列表对象的任意指定位置
a.insert(0, 10)
#乘法扩展
a = a * 3
#删除列表指定位置的元素
del a[0]
#删除并返回指定位置的元素，可以有参数
a.pop()
#删除首次出现的指定元素，若不存在该元素抛出异常
a.remove(20)
```

### 元素的访问

``` python
#可以通过索引直接访问元素，若超出范围则抛出异常
b = a[0]
#获得指定元素首次出现的索引位置
#也可以添加参数index(value, start)或index(value, start, end)
a.index(40)
#获得指定元素在列表中出现的次数
a.count(20)
#列表长度
len(a)
```

### 成员资格判断

判断列表中是否存在指定的元素，可以使用count()来返回元素个数，也可以使用 in 关键字。

``` python
a = [10, 20]
20 in a        #true
```

### 列表的遍历

```python
a = [1, 2, 3]
for x in a:
    print(x)
```

### 列表排序

1. 修改原列表，不新建列表的排序

   ```python
   a = [2, 1, 4, 5]
   #升序排序
   a.sort()
   #降序排序
   a.sort(reverse=True)
   #打乱顺序
   random.shuffle(a)
   ```

   

2. 建新列表的排序

   ```python
   #默认升序
   b = sorted(a)
   #降序
   c = sorted(a, reverse=True)
   ```

   

### reversed()返回迭代器

内置函数reversed()也支持进行逆序排列，与列表对象reverse()方法不同的是，内置函数不对原列表做任何修改，只是返回一个逆序排列的迭代器对象。

```python
a = [1, 2, 3]
b = reversed(a)
list(b)           #[3, 2, 1]
list(b)           #[]    只能迭代一次
```

### 最大值和最小值

```python
a = [1, 2, 3]
max(a)            #3
min(a)            #1
```

### 元组tuple

列表属于可变序列，可以任意修改列表中的元素。元组属于不可变序列，不能修改元组中的元素。

```python
#通过()创建元组，小括号可以省略
a = (1, 2, 3)
a = 1, 2, 3
#如果元组只有一个元素，则必须后面加逗号，这是因为解释器会把(1)解释为整数1，而(1,)解释为元组。

#通过内置函数，本质上是将其他类型对象转换为了typle对象
a = tuple()
a = tuple("abc")
a = tuple(range(3))
a = tuple([1, 2, 3])

#元组的删除
del b

#排序生成新的列表对象
sorted(a)
```

### zip

zip(列表1，列表2，...) 将多个列表对应位置的元素组合成为元组，并返回zip对象

```python
a = [1, 2, 3]
b = [4, 5, 6]
c = zip(a, b)
list(c)     #[(1, 4), (2, 5), (3, 6)] 

```

### 生成器推导式创建元组

生成器推导式生成的是一个生成器对象。可以将其转化为列表或者元组。可以使用该对象的\_\_next\_\_() 方法进行遍历，或者直接作为迭代器来使用。

``` python
s = (x*2 for x in range(5))
tuple(s)       #(0, 2, 4, 6, 8)
list(s)        #[] 因为生成器只能使用一次
```

### 元组总结

1. 核心特点：不可变序列
2. 访问速度和处理速度比列表快
3. 与整数和字符串一样，元组可以作为字典的健，列表则不能

### 字典

字典是 “键值对” 的无序可变序列。字典中每个对象都是一个 “键值对” ，包括 “键对象” 和 “值对象” 。

"健" 是任意不可变的数据，比如：整数、浮点数、字符串、元组。

”值“ 可以是任意的数据，并且可以重复。

### 字典的创建

```python
a = {'name':'Jack', 'age':18}
b = dict(name='Jack', age=18)
c = dict([("name","Jack"), ("age",18)])

#通过zip()创建字典
k = ["name", "age"]
v = ["Jack", 18]
a = dict(zip(k, v))

#通过fromkeys创建值为空的字典
a = dict.fromkeys(['name', 'age'])
#{'name':None, 'age':None, 'job':None}
```

### 字典元素的访问

1. 通过键获得值，若键不存在，则抛出异常。

   ```python
   name = a['name']
   ```

   

2. 通过 get() 方法获得 “值” 。若键不存在，返回None。

   ```python
   name = a.get('name')
   #若不存在，返回第二个参数
   name = a.get('name', '匿名用户')
   ```

3. 列出所有的键值对

   ```python
   a.items()
   ```

   

4. 列出所有的键，列出所有的值

   ```python
   a.keys()
   a.values()
   ```

   

5. len() 返回键值对的个数

6. 检测一个键是否在字典中

   ```python
   'name' in a
   ```

   

### 字典元素的添加、修改、删除

1. 新增（或覆盖） “键值对” 

   ```python
   a['address'] = 'sun street'
   ```

   

2. 使用 update() 将新字典中所有键值对全部添加（或覆盖）到旧字典对象上。

   ```python
   a = {'name':'Jack', 'age':'18'}
   b = {'name':'Joey', 'age':'33', 'sex':'male'}
   a.update(b)
   ```

   

3. 字典中元素的删除

   ```python
   #删除指定键值对
   del(a['name'])
   #删除所有键值对
   a.clear()
   #删除指定并返回对应的“值对象"
   age = a.pop('age')
   ```

   

4. 随机删除和返回该键值对。

   ```python
   random = a.popitem()
   ```

   

### 序列解包

序列解包可以用于元组、列表、字典。可以方便的对多个变量赋值。

```python
a, b, c = 1, 2, 3
(a, b, c) = (1, 2, 3)
[a, b, c] = [1, 2, 3]
```

序列解包用于字典时，默认时对”键“进行操作。

```python
a = {'name':'Jack', 'age':18}
#获取键
name_key, age_key = a
#获取值
name_value, age_value = a.values()
#获取键值对（返回一个元组）
name_pair, value_pair = a.items()

```

### 字典原理

字典对象的核心是散列表，即稀疏数组（总有空白元素的数组），数组的每个单元叫做bucket。每个bucket有两部分：一个是键对象的引用，一个是值对象的引用。

由于所有bucket结构和大小一致，所以可以通过偏移量来读取指定bucket。

用哈希算法将 ”键“ 算出哈希值，转换为二进制后。如果散列表有8个位置，就按照后三位映射，如果发生哈希碰撞，往前找三位。

### 字典总结

1. 键必须是可散列的
   1. 数字、字符串、元组，都是可散列的
   2. 自定义对象需要支持下面三点：
      1. 支持hash()函数
      2. 支持通过\_\_eq\_\_() 方法检测相等性
      3. 若 a\=\=b 为真，则hash(a)\=\=hash(b)也为真
2. 字典在内存中开销巨大，典型的空间换时间
3. 键查询速度很快
4. 往字典里面添加新键可能导致扩容，导致散列表中键的次序变化。因此，不能在遍历字典的同时进行字典的修改。

### 集合

无序可变，不可重复。底层是字典实现，所有的元素是字典中的 ”键对象“ 。

```python
#集合的创建
a = {1,2,3}
#添加
a.add(4)
#将其他类型转换为集合
b = [1, 2, 3]
set(b)
#删除指定元素
a.remove(1)
#清空整个集合
a.clear()
#并集
a|b
a.union(b)
#交集
a&b
a.intersection(b)
#差集
a-b
a.difference(b)


```

### 单分支选择结构

```python
if 条件表达式:
    语句/语句块
```

条件表达式中，空的列表或字符串是False，不能有赋值操作符。

### 双分支选择结构

```python
if 条件表达式:
    语句1/语句块1
else:
    语句2/语句块2
```

### 三元条件运算符

条件为真的值  if  (条件表达式)  else  条件为假的值

```python
a = input("Please input a number:")
print("less than 10" if int(a) < 10 else "more than 10")
```

### 多分支选择结构

```python
if 条件表达式1:
    语句1/语句块1
elif 条件表达式2:
    语句2/语句块2
else:
    语句块3/语句块3

```

### 选择结构的嵌套

选择结构可以嵌套，缩进量决定了代码的从属关系。

```python
if 表达式:
    语句1
    if 表达式2:
        语句2
    else:
        语句3
else:
    语句4
```

### while循环

```python
while 条件表达式:
    循环体语句
```

### for循环

```python
for 变量 in 可迭代对象:
    循环体语句
```

### 可迭代对象

1. 序列。包含：字符串、列表、元组
2. 字典
3. 迭代器对象（iterator)
4. 生成器函数（generator）

### 循环 else

while、for循环可以附带一个else语句（可选）。如果for、while语句没有被break语句结束，则会执行else子句，否则不执行。

```python
while 条件表达式:
    循环体
else:
    语句块

#或者
for 变量 in 可迭代对象:
    循环体
else:
    语句块
```

### zip() 并行迭代

zip() 函数可以对多个序列进行并行迭代，在最短序列 ”用完“ 时就会停止。

```python
names = ("Jack", "Jone", "Max")
ages = (18, 19, 20)

for name,age in zip(names, ages):
    print("name:{0}, age:{1}".format(name, age))
```

### 推导式创建序列

从一个或多个迭代器快速创建序列的一种方法。它可以将循环和条件判断结合，从而避免冗长的代码。

### 列表推导式

```python
[表达式 for item in 可迭代对象]
或者 [表达式 for item in 可迭代对象 if 条件判断]
#例
point = [(x, y) for x in range(10) for y in range(10)]
```

### 字典推导式

```python
{key_expression : value_expression for expression in iterator}
#例
text = "HelloWorld!"
char_count = {char : text.count(char) for char in text}
```

### 集合推导式

```python
{表达式 for item in 可迭代对象 if 条件判断}
```

### 生成器推导式（生成元组）

```python
(x for x in range(100) if x%9==0)
```

一个生成器只能运行一次，第一次迭代可以得到数据，第二次迭代发现数据已经没有了。

### 函数的分类

1. 内置函数

   在python中直接可以使用的函数，str()、list()、len()

2. 标准库函数

   通过import语句导入库，然后使用其中定义的函数

3. 第三方库函数

   Python社区中提供的库，这些库可以被安装，然后通过import语句导入

4. 用户自定义函数

   开发中适应用户自身需求定义的函数。

### 函数的定义和调用

```python
def 函数名(参数列表):
    '''文档字符串'''
    函数体/若干语句
```

1. Python执行 def 时，会创建一个函数对象，并绑定到函数名变量上。
2. 参数列表
   1. 圆括号内是形式参数列表，有多个参数则使用逗号隔开
   2. 形式参数不需要声明类型，也不需要指定函数返回值类型
   3. 无参数，也必须保留空的圆括号
   4. 实参列表必须与形参列表一一对应
3. return 返回值
   1. 如果函数体中包含return语句，则结束函数执行并返回值
   2. 如果函数体中不包含return语句，则返回None值
   3. 要返回多个返回值，使用列表、元组、字典、集合将多个值“存起来”即可。
4. 调用函数之前，必须要先定义函数，即先调用 def 创建函数对象
   1. 内置函数对象会自动创建
   2. 标准库和第三方库函数，通过import导入模块时，会执行模块中的 def 语句

### 文档字符串（函数的注释）

在函数体的开始部分附上函数定义的说明。要使用三个单引号或三个双引号。中间可以加入多行文字进行说明。

可以调用 help(函数名.\_\_doc\_\_) 可以打印输出函数的文档字符串。

### 变量的作用域

变量起作用的范围是作用域，不同作用域同名变量之间互不影响。

1. 全局变量：

   1. 在函数和类定义之外声明的变量，作用域为定义的模块，从定义位置开始直到模块结束。

   2. 全局变量降低了函数的通用性和可读性。应尽量避免全局变量的使用。

   3. 全局变量一般做常量使用。

   4. 函数内要改变全局变量的值，使用global声明一下

      ```python
      a = 200
      def function():
          global a        #如果要在函数内改变全局变量，增加此声明
          a = 300
      
      print(a)
      ```

      

2. 局部变量：
   1. 在函数体中声明的变量。（包含形式参数）
   2. 局部变量的引用比全局变量快，优先考虑使用
   3. 如果局部变量和全局变量同名，则在函数内隐藏全局变量，只使用同名的局部变量

```python
def function():
    print(locals())        #打印所有的局部变量
    print(globals())       #打印所有的全局变量
```

### 参数的传递

函数的参数传递本质上就是：从实参到形参的赋值操作。Python中，所有的赋值操作都是 “引用的赋值” 。所以，Python中赋值操作都是 “引用的赋值”， 参数的传递都是 “引用传递”， 不是 “值传递”。  

1. 对 “可变对象” 进行 “写操作”， 直接作用于原对象本身。
2. 对 “不可变对象” 进行 “写操作”， 会产生一个新的 “对象空间”，并用新的值填充这块空间，即原引用会指向一个新的对象。

可变对象有：字典、列表、集合、自定义的对象等

不可变对象有：数字、字符串、元组、function等

### 浅拷贝和深拷贝

内置函数分别是：copy(浅拷贝)、deepcopy(深拷贝)

1. 浅拷贝：不拷贝子对象的内容，只是拷贝子对象的引用
2. 深拷贝：会连子对象的内存也全部拷贝一份，对子对象的修改不会影响源对象。

传递的参数是不可变对象时，实际上传递的是对象的引用。但在 “写操作” 时，会创建一个新的对象拷贝，这个拷贝使用的是 “浅拷贝” ，不是 “深拷贝”。

### 参数的类型

1. 位置参数

   函数调用时，实参默认按位置顺序传递，需要个数和形参匹配。

2. 默认值参数

   某些参数可以设置默认值，这样这些参数在传递时就是可选的。默认值参数必须放在位置参数后面。

   ```python
   def function(a, b, c = 10):
       print(a, b, c)
   ```

   

3. 命名参数

   ```python
   def function(a, b, c):
       print(a, b, c)
   
   function(c = 1, b = 2, a = 1)
   ```

   

4. 可变参数

   可变数量的参数。分为两种情况：

   1. *param（一个星号），将多个参数收集到一个 “元组” 对象中。

   2. **param（两个星号），将多个参数收集到一个 “字典” 对象中。

      ```python
      def function(a, b, *c):
          print(a, b, c)
          
      function(1, 2, 3, 4)
      
      def function2(a, b, **c):
          print(a, b, c)
          
      function2(1, 2, name = "Jack", age = 19)
      ```

      

5. 强制命名参数

   在带星号的 “可变参数” 后面增加新的参数，必须时 “强制命名参数”。（因为可变参数的数量不确定）

### lambda表达式

可以用来声明匿名函数，lambda函数是一种简单的、在同一行中定义函数的方法。lambda函数实际上生成了一个函数对象。

lambda表达式只允许包含一个表达式，不能包含复杂语句，该表达式的计算结果就是函数的返回值。

基本语法：

```python
#运算结果是返回值
lambda arg1, arg2, arg3... : <表达式>

#例
function = lambda a, b, c : a + b + c
print(function(1, 2, 3))
```

### eval()函数

功能：将字符串str当成是有效的表达式来求值并返回计算结果。

语法：eval(source[,globals[,locals]]) -> value

参数：

1. source：一个Python表达式或函数compile() 返回的代码对象
2. globals：可选。必须是dictionary
3. locals：可选。任意映射对象。

```python
dic = dict(a = 100, b = 200)
d = eval("a + b", dic)
print(d)
```

### 递归函数

递归函数指的是：自己调用自己的函数，在函数体内部直接或间接的自己调用自己。每个递归都包含以下两个部分：

1. 终止条件

   表示递归什么时候结束，一般用于返回值，不再调用自己。

2. 递归步骤

   把第n步的值和第n-1步相关联

### 嵌套函数（内部函数）

在函数内部定义函数。

```python
def f1():
    print('f1 running...')
    
    def f2():
        print('f2 running...')
        
    f2()

f1()
```

f2定义在f1中，就只能在f1中调用。

应用场景：

1. 封装 - 数据隐藏

   外部无法访问 “嵌套函数”

2. 贯彻 DRY (Don't Repeat Yourself) 原则

   嵌套函数，可以让我们在函数内部避免重复代码。

3. 闭包

### nonlocal关键字

nonlocal  用来声明外层的局部变量

global      用来声明全局变量

### LEGB规则

Python在查找 “名称” 时，是按照 LEGB 规则查找的：

1. Local：指的是函数或者类的方法内部
2. Enclosed：指的是嵌套函数（一个函数包裹另一个函数，闭包）
3. Global：指的是模块中的全局变量
4. Build in：指的是Python为自己保留的特殊名称

### 类的定义

```python
class Student:
    
    def __init__(self, name, age):  #self必须位于第一个参数
        self.name = name
        self.age = age
        
	def print_age(self):
        print(self.age)
        

student = Student("Jack", 19) #调用构造函数
```

1. \_\_init\_\_() 方法：初始化创建好的对象，初始化指的是：给实例属性赋值
2. \_\_new\_\_() 方法：用于创建对象，==一般无需主动定义该方法==

3. 创建好的Python对象包含如下部分：
   1. id (identity 识别码)
   2. type (对象类型)
   3. value (对象的值)
      1. 属性（attribute)
      2. 方法（method)

### 实例属性

实例属性是从属于实例对象的属性，也称为 “实例对象”。他的使用有如下几个要点：

1. 实例属性一般在\_\_init\_\_() 方法中通过如下代码定义：

   self.实例对象 = 初始值

2. 在本类的其他实例方法中，也是通过self进行访问：

   self.实例属性名

3. 创建实例对象后，通过实例对象访问：

   object1 = 类名()     #创建对象，调用\_\_init\_\_() 初始化属性

   object1.实例属性名 = 值  #可以给已有属性赋值，也可以==新加属性==

### 实例方法

实例方法是从属于实例对象的方法。实例方法的定义格式如下：

```python
def 方法名(self, 形参列表):
    函数体
    

对象.方法名(实参列表)   #方法的调用格式
```

1. 定义实例方法时，第一个参数必须为self。和前面一样，self指当前的实例对象
2. 调用实例方法时，不需要也不能给self传参。self由解释器自动传参。

3. 实例对象的方法调用本质：

   ```python
   student = Student()
   student.print_age()
   #解释器翻译为：
   Student.print_age(student)
   ```

4. 函数是类外的语句块，方法是类内定义的语句块。

5. dir(object) 可以获得对象的所有属性、方法
6. object.\_\_dict\_\_ 对象的属性字典
7. pass 空语句
8. isinstance (对象，类型)  判断 “对象” 是不是 “指定类型”